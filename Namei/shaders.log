Vertex shader source:
  1: #version 110
  2: uniform vec3 light0_direction;
  3: uniform vec3 light0_diffuse;
  4: uniform vec3 eyePosition;
  5: varying vec2 diffTexCoord;
  6: uniform float textureOffset;
  7: uniform vec3 atmosphereRadius;
  8: uniform float mieCoeff;
  9: uniform float mieH;
 10: uniform float mieK;
 11: uniform vec3 rayleighCoeff;
 12: uniform float rayleighH;
 13: uniform vec3 scatterCoeffSum;
 14: uniform vec3 invScatterCoeffSum;
 15: uniform vec3 extinctionCoeff;
 16: vec3 eyeDir = normalize(eyePosition - gl_Vertex.xyz);
 17: float NV = dot(gl_Normal, eyeDir);
 18: uniform vec3 ambientColor;
 19: uniform float opacity;
 20: varying vec4 diff;
 21: varying vec3 scatterEx;
 22: 
 23: void main(void)
 24: {
 25: float NL;
 26: diff = vec4(ambientColor, opacity);
 27: NL = max(0.0, dot(gl_Normal, light0_direction));
 28: diff.rgb += light0_diffuse * NL;
 29: diffTexCoord = gl_MultiTexCoord0.st + vec2(textureOffset, 0.0);
 30: {
 31:     float rq = dot(eyePosition, eyeDir);
 32:     float qq = dot(eyePosition, eyePosition) - atmosphereRadius.y;
 33:     float d = sqrt(rq * rq - qq);
 34:     vec3 atmEnter = eyePosition + min(0.0, (-rq + d)) * eyeDir;
 35:     vec3 atmLeave = gl_Vertex.xyz;
 36:     vec3 atmSamplePoint = (atmEnter + atmLeave) * 0.5;
 37:     vec3 atmSamplePointSun = atmEnter * 0.5 + atmLeave * 0.5;
 38:     rq = dot(atmSamplePointSun, light0_direction);
 39:     qq = dot(atmSamplePointSun, atmSamplePointSun) - atmosphereRadius.y;
 40:     d = sqrt(rq * rq - qq);
 41:     float distSun = -rq + d;
 42:     float distAtm = length(atmEnter - atmLeave);
 43:     float density = 0.0;
 44:     atmSamplePoint = atmEnter * 0.333 + atmLeave * 0.667;
 45:     float h = max(0.0, length(atmSamplePoint) - atmosphereRadius.z);
 46:     density += exp(-h * mieH);
 47:     atmSamplePoint = atmEnter * 0.667 + atmLeave * 0.333;
 48:     h = max(0.0, length(atmSamplePoint) - atmosphereRadius.z);
 49:     density += exp(-h * mieH);
 50:     vec3 sunColor = exp(-extinctionCoeff * density * distSun);
 51:     vec3 ex = exp(-extinctionCoeff * density * distAtm);
 52:     float cosTheta = dot(eyeDir, light0_direction);
 53:     float phMie = (1.0 - mieK * mieK) / ((1.0 - mieK * cosTheta) * (1.0 - mieK * cosTheta));
 54:     float phRayleigh = 1.0;
 55:     scatterEx = ex;
 56:     gl_FrontSecondaryColor.rgb = (phRayleigh * rayleighCoeff + phMie * mieCoeff) * invScatterCoeffSum * sunColor * (1.0 - exp(-scatterCoeffSum * density * distAtm));
 57: }
 58: gl_Position = ftransform();
 59: }

Fragment shader source:
  1: #version 110
  2: uniform sampler2D diffTex;
  3: varying vec2 diffTexCoord;
  4: varying vec4 diff;
  5: varying vec3 scatterEx;
  6: 
  7: void main(void)
  8: {
  9: vec4 color;
 10: color = texture2D(diffTex, diffTexCoord.st);
 11: gl_FragColor = color * diff;
 12: gl_FragColor.rgb = gl_FragColor.rgb * scatterEx + gl_SecondaryColor.rgb;
 13: }

Vertex shader source:
  1: #version 110
  2: uniform vec3 light0_direction;
  3: uniform vec3 light0_diffuse;
  4: uniform vec3 eyePosition;
  5: uniform vec3 atmosphereRadius;
  6: uniform float mieCoeff;
  7: uniform float mieH;
  8: uniform float mieK;
  9: uniform vec3 rayleighCoeff;
 10: uniform float rayleighH;
 11: uniform vec3 scatterCoeffSum;
 12: uniform vec3 invScatterCoeffSum;
 13: uniform vec3 extinctionCoeff;
 14: varying vec3 scatteredColor0;
 15: vec3 eyeDir = normalize(eyePosition - gl_Vertex.xyz);
 16: float NV = dot(gl_Normal, eyeDir);
 17: varying vec3 scatterEx;
 18: varying vec3 eyeDir_obj;
 19: 
 20: void main(void)
 21: {
 22: float NL;
 23: {
 24:     float rq = dot(eyePosition, eyeDir);
 25:     float qq = dot(eyePosition, eyePosition) - atmosphereRadius.y;
 26:     float d = sqrt(rq * rq - qq);
 27:     vec3 atmEnter = eyePosition + min(0.0, (-rq + d)) * eyeDir;
 28:     vec3 atmLeave = gl_Vertex.xyz;
 29:     vec3 atmSamplePoint = (atmEnter + atmLeave) * 0.5;
 30:     vec3 atmSamplePointSun = atmEnter * 0.5 + atmLeave * 0.5;
 31:     rq = dot(atmSamplePointSun, light0_direction);
 32:     qq = dot(atmSamplePointSun, atmSamplePointSun) - atmosphereRadius.y;
 33:     d = sqrt(rq * rq - qq);
 34:     float distSun = -rq + d;
 35:     float distAtm = length(atmEnter - atmLeave);
 36:     float density = 0.0;
 37:     atmSamplePoint = atmEnter * 0.333 + atmLeave * 0.667;
 38:     float h = max(0.0, length(atmSamplePoint) - atmosphereRadius.z);
 39:     density += exp(-h * mieH);
 40:     atmSamplePoint = atmEnter * 0.667 + atmLeave * 0.333;
 41:     h = max(0.0, length(atmSamplePoint) - atmosphereRadius.z);
 42:     density += exp(-h * mieH);
 43:     vec3 sunColor = exp(-extinctionCoeff * density * distSun);
 44:     vec3 ex = exp(-extinctionCoeff * density * distAtm);
 45:     scatterEx = ex;
 46:     scatteredColor0 = sunColor * (1.0 - exp(-scatterCoeffSum * density * distAtm));
 47: }
 48: eyeDir_obj = eyeDir;
 49: gl_Position = ftransform();
 50: }

Fragment shader source:
  1: #version 110
  2: varying vec3 scatterEx;
  3: varying vec3 eyeDir_obj;
  4: uniform float mieK;
  5: uniform float mieCoeff;
  6: uniform vec3  rayleighCoeff;
  7: uniform vec3  invScatterCoeffSum;
  8: uniform vec3 light0_direction;
  9: varying vec3 scatteredColor0;
 10: 
 11: void main(void)
 12: {
 13: vec3 color = vec3(0.0, 0.0, 0.0);
 14: vec3 V = normalize(eyeDir_obj);
 15:     float cosTheta = dot(V, light0_direction);
 16:     float phMie = (1.0 - mieK * mieK) / ((1.0 - mieK * cosTheta) * (1.0 - mieK * cosTheta));
 17:     float phRayleigh = 1.0;
 18:     color += (phRayleigh * rayleighCoeff + phMie * mieCoeff) * invScatterCoeffSum * scatteredColor0;
 19:     gl_FragColor = vec4(color, dot(scatterEx, vec3(0.333, 0.333, 0.333)));
 20: }

